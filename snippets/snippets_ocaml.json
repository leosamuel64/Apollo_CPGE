{
	"Function": {
		"prefix": ["spec", "new"],
		"body": ["$BLOCK_COMMENT_START CONTRAT", "${3:Description}", "* Type  : $4", "* Param : $5", 
			"* Pre   : $6", "* Result: $7 $BLOCK_COMMENT_END","let ${1:fonction} ${2:args} = ${0:\"TODO\"}","",
			"$BLOCK_COMMENT_START TESTS $BLOCK_COMMENT_END","","let%test _ = ${1} ${2} = \"TODO\" ",
			"let%test _ = ${1} ${2} = \"TODO\" ","let%test _ = ${1} ${2} = \"TODO\" "],
		"description": "Init a new function with its contracts and unit tests"
	},

	"Contract": {
		"prefix": ["cc", "contrat"],
		"body": ["$BLOCK_COMMENT_START CONTRAT", "${2:Description}", "* Type  : $3", "* Param : $4", 
			"* Pre   : $5", "* Result: $0 $BLOCK_COMMENT_END"],
		"description": "Create a comment block that contains differents fields for a function's contract"
	},

	"Test Block": {
		"prefix": ["btest", "tests"],
		"body": ["$BLOCK_COMMENT_START TESTS $BLOCK_COMMENT_END","",
			"let%test _ = ${1:function} ${2:args} = ${3:\"TODO\"} ",
			"let%test _ = ${1} ${2} = ${4:\"TODO\"} ",
			"let%test _ = ${1} ${2} = ${0:\"TODO\"} "],
		"description": "Create a three unit tests for a fonction"
	},

	"Auxiliary": {
		"prefix": ["af", "aux"],
		"body": ["let rec ${1:aux} ${2:args} =", "\t${0:\"TODO\"}", "in","${1} ${2}"],
		"description": "Init an auxiliary function with an accumulator"
	},

	"Anonymous": {
		"prefix": ["fun", "(fun)"],
		"body": ["(fun ${1:args} -> ${0:something})"],
		"description": "Init an anonymous function"
	},

	"Test": {
		"prefix": ["test", "let%test"],
		"body": ["let%test _ = ${1:args} = ${0:\"TODO\"} "],
		"description": "Create an unit test"
    },
    


	"Condition": {
		"prefix": ["if"],
		"body": ["if ${1:condition}", "then ${2:something}", "else ${0:something_else}"],
		"description": "Init a condition operator: if"
	},

	"for": {
		"prefix": ["for"],
		"body": ["for i=${1:<début>} to ${2:<fin>} do","  ${3:<code>}", "done;"],
		"description": "Init a for Loop structure"
	},

	"forArray": {
		"prefix": ["forArray","fa"],
		"body": ["for i=0 to (Array.length ${2:<Array>}-1) do","  ${3:<code>}", "done;"],
		"description": "Init a for Loop structure for Array"
	},

	"while": {
		"prefix": ["while"],
		"body": ["while ${1:<condition>} do","  ${2:<code>}", "done;"],
		"description": "Init a while Loop structure"
	},

	"stackcreate": {
		"prefix": ["Stack.create","sc"],
		"body": ["Stack.create ()"],
		"description": "Create a new empty Stack"
	},

	"stackpush": {
		"prefix": ["Stack.push","spu"],
		"body": ["Stack.push ${1:<élément>} ${2:<pile>}"],
		"description": "Push an element into a Stack"
	},

	"stackpop": {
		"prefix": ["Stack.push","spo"],
		"body": ["Stack.pop ${1:<pile>}"],
		"description": "Pop an element from a Stack"
	},

	"stackisempty": {
		"prefix": ["Stack.is_empty","sie"],
		"body": ["Stack.is_empty ${1:<pile>}"],
		"description": "return True when the Stack is empty"
	},

	"Compare": {
		"prefix": ["match"],
		"body": ["match ${1:something} with", "| ${2}\t-> ${0}", "| ${3}\t-> "],
		"description": "Init a condition operator: match with"
	},

	"Compare a List": {
		"prefix": ["ml", "match_list"],
		"body": ["match ${1:liste} with", "| []\t-> ${2}", "| t::q\t-> ${0}"],
		"description": "Init a condition operator: match with for a list"
	},

	"Compare an Option": {
		"prefix": ["mo","match_option"],
		"body": ["match ${1:option} with", "| None\t\t-> ${2}", "| Some x\t-> ${0}"],
		"description": "Init a condition operator: match with for an option type"
    },
    


	"Binary Tree": {
		"prefix": ["tree","arbre_bin"],
		"body": ["type 'a arbre_bin = ", "| Empty", "| Node of 'a arbre_bin * 'a * 'a arbre_bin","",
		"let test_tree = (Node(Node(Empty, 1, Empty), 2, Node(Empty, 3, Empty)))"],
		"description": "Init a binary tree type"
	},

	"Non Binary Tree": {
		"prefix": ["tree-n","arbre_naire"],
		"body": ["type 'a arbre_naire = ", "| Node of 'a * 'a arbre_naire list","",
		"let test_tree = Node(0, [(Node(5,[]));(Node(13,[]));(Node(42,[]))])","","",
		"$BLOCK_COMMENT_START CONTRAT","Permet de recuperer la racine d'un arbre n-aire",
		"* Type  : racine: 'a arbre_naire -> 'a ",
		"* Param : abr, un arbre n-aire",
		"* Pre   : abr non Vide",
		"* Result: l'element en racine de l'arbre abr $BLOCK_COMMENT_END",
		"let racine (Node(racine,_)) = racine","","$BLOCK_COMMENT_START TESTS $BLOCK_COMMENT_END","",
		"let%test _ = racine (Node(1, [])) = 1",
		"let%test _ = racine (Node('z', [])) = 'z'",
		"let%test _ = racine (Node(\"test\", [])) = \"test\"","","","$BLOCK_COMMENT_START CONTRAT",
		"Permet de recuperer les fils d'un arbre n-aire",
		"* Type  : fils: 'a arbre_naire -> 'a arbre_naire list",
		"* Param : abr, un abre n-aire ",
		"* Pre   : abr non Vide",
		"* Result: la liste contenant les fils de m'arbre abr $BLOCK_COMMENT_END",
		"let fils (Node(_,fils)) = fils","","$BLOCK_COMMENT_START TEST $BLOCK_COMMENT_END","",
		"let%test _ = fils (Node(1, [])) = []",
		"let%test _ = fils arbre_test = [(Node(5,[]));(Node(13,[]));(Node(42,[]))]"],
		"description": "Init a non binary tree type and getters"
	},


    
	"Fold Left": {
		"prefix": ["left","fold_left"],
		"body": ["List.fold_left (fun acc t -> ${0:(t::acc)}) [] ${1:liste}"],
		"description": "Init a list iterator: fold left"
	},

	"Fold Right": {
		"prefix": ["right","fold_right"],
		"body": ["List.fold_right (fun t qt -> ${0:(t::qt)}) ${1:liste} []"],
		"description": "Init a list iterator: fold right"
	},

	"Map": {
		"prefix": ["map"],
		"body": ["List.map (fun elt -> ${0:elt modified}) ${1:liste}"],
		"description": "Init a list iterator: map"
	},

	"Iteration": {
		"prefix": ["iter"],
		"body": ["List.iter (fun elt -> ${0:elt modified}) ${1:liste}"],
		"description": "Init a list iterator: iter (map for display)"
	},



	"I don't know": {
		"prefix": ["idk","ocaml"],
		"body": ["¯\\_(ツ)_/¯"],
		"description": "When you end up unable to understand your own code"
	}
}