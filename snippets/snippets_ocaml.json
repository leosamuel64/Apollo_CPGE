{
	"Function": {
		"prefix": ["spec", "new"],
		"body": ["$BLOCK_COMMENT_START CONTRAT", "${3:Description}", "* Type  : $4", "* Param : $5", 
			"* Pre   : $6", "* Result: $7 $BLOCK_COMMENT_END","let ${1:fonction} ${2:args} = ${0:\"TODO\"}","",
			"$BLOCK_COMMENT_START TESTS $BLOCK_COMMENT_END","","let%test _ = ${1} ${2} = \"TODO\" ",
			"let%test _ = ${1} ${2} = \"TODO\" ","let%test _ = ${1} ${2} = \"TODO\" "],
		"description": "Init a new function with its contracts and unit tests"
	},

	"Contract": {
		"prefix": ["cc", "contrat"],
		"body": ["$BLOCK_COMMENT_START CONTRAT", "${2:Description}", "* Type  : $3", "* Param : $4", 
			"* Pre   : $5", "* Result: $0 $BLOCK_COMMENT_END"],
		"description": "Create a comment block that contains differents fields for a function's contract"
	},

	"Test Block": {
		"prefix": ["btest", "tests"],
		"body": ["$BLOCK_COMMENT_START TESTS $BLOCK_COMMENT_END","",
			"let%test _ = ${1:function} ${2:args} = ${3:\"TODO\"} ",
			"let%test _ = ${1} ${2} = ${4:\"TODO\"} ",
			"let%test _ = ${1} ${2} = ${0:\"TODO\"} "],
		"description": "Create a three unit tests for a fonction"
	},

	"Auxiliary": {
		"prefix": ["af", "aux"],
		"body": ["let rec ${1:aux} ${2:args} =", "\t${0:\"TODO\"}", "in","${1} ${2}"],
		"description": "Init an auxiliary function with an accumulator"
	},

	"Anonymous": {
		"prefix": ["fun", "(fun)"],
		"body": ["(fun ${1:args} -> ${0:something})"],
		"description": "Init an anonymous function"
	},

	"Test": {
		"prefix": ["test", "let%test"],
		"body": ["let%test _ = ${1:args} = ${0:\"TODO\"} "],
		"description": "Create an unit test"
    },
    


	"Condition": {
		"prefix": ["if"],
		"body": ["if ${1:condition}", "then ${2:something}", "else ${0:something_else}"],
		"description": "Init a condition operator: if"
	},

	"for": {
		"prefix": ["for"],
		"body": ["for i=${1:<dÃ©but>} to ${2:<fin>} do","  ${3:<code>}", "done;"],
		"description": "Init a for Loop structure"
	},

	"forArray": {
		"prefix": ["forArray","fa"],
		"body": ["for i=0 to (Array.length ${2:<Array>}-1) do","  ${3:<code>}", "done;"],
		"description": "Init a for Loop structure for Array"
	},

	"while": {
		"prefix": ["while"],
		"body": ["while ${1:<condition>} do","  ${2:<code>}", "done;"],
		"description": "Init a while Loop structure"
	},

	"stackcreate": {
		"prefix": ["Stack.create","sc"],
		"body": ["Stack.create ()"],
		"description": "Create a new empty Stack"
	},

	"queuecreate": {
		"prefix": ["Queue.create"],
		"body": ["Queue.create ()"],
		"description": "Create a new empty Queue"
	},



	"stackpush": {
		"prefix": ["Stack.push","spu"],
		"body": ["Stack.push ${1:<Ã©lÃ©ment>}  ${2:<pile>} "],
		"description": "Push an element into a Stack"
	},

	"queueadd": {
		"prefix": ["Queue.add"],
		"body": ["Queue.add ${1:<Ã©lÃ©ment>}  ${2:<file>} "],
		"description": "Add an element into a Queue"
	},

	"queuetake": {
		"prefix": ["Queue.take"],
		"body": ["Queue.take ${1:<file>}"],
		"description": "Take an element from a Queue"
	},


	"stackpop": {
		"prefix": ["Stack.pop","spo"],
		"body": ["Stack.pop ${1:<pile>}"],
		"description": "Pop an element from a Stack"
	},

	"stackisempty": {
		"prefix": ["Stack.is_empty","sie"],
		"body": ["Stack.is_empty ${1:<pile>}"],
		"description": "return True when the Stack is empty"
	},

	"queueisempty": {
		"prefix": ["Queue.is_empty"],
		"body": ["Queue.is_empty ${1:<file>}"],
		"description": "return True when the Queue is empty"
	},

	"hashcreate": {
		"prefix": ["Hashtbl.create"],
		"body": ["Hashtbl.create ${1:<longueur>}"],
		"description": "CrÃ©er une table de hashage d'une certaine longueur"
	},

	"hashadd": {
		"prefix": ["Hashtbl.add"],
		"body": ["Hashtbl.add ${1:<dict>} ${2:<key>} ${3:<value>}"],
		"description": "Ajoute un Ã©lÃ©ment dans le dico"
	},

	"hashfind": {
		"prefix": ["Hashtbl.find"],
		"body": ["Hashtbl.find ${1:<dict>} ${2:<key>}"],
		"description": "Retourne la valeur associÃ© Ã  la clef"
	},

	"hashmem": {
		"prefix": ["Hashtbl.mem"],
		"body": ["Hashtbl.mem ${1:<dict>} ${2:<key>}"],
		"description": "Teste si une clef est prÃ©sente dans un dico"
	},

	"hashremove": {
		"prefix": ["Hashtbl.remove"],
		"body": ["Hashtbl.remove ${1:<dict>} ${2:<key>}"],
		"description": "EnlÃ¨ve une clef du dico"
	},

	"arraymake": {
		"prefix": ["Array.make"],
		"body": ["Array.make ${1:<len>} ${2:<value>}"],
		"description": "CrÃ©er un tableau (mutable) de longueur len remplie de value "
	},

	"arraylen": {
		"prefix": ["Array.length"],
		"body": ["Array.length ${1:<tableau>}"],
		"description": "Renvoie la longueur du tableau  "
	},

	"arrayconcat": {
		"prefix": ["Array.concat"],
		"body": ["Array.concat [${1:<t1>};${2:<t2>}]"],
		"description": "Concat les tableaux d'une liste de tableaux"
	},

	"arraycp": {
		"prefix": ["Array.copy"],
		"body": ["Array.copy ${1:<tableau>}"],
		"description": "Fait une vrai copie du tableau"
	},

	"arraymap": {
		"prefix": ["Array.map"],
		"body": ["Array.map (${1:<fun>}) ${2:<t>}"],
		"description": "applique une fonction Ã  un tableau"
	},

	"arrayiter": {
		"prefix": ["Array.iter"],
		"body": ["Array.iter (${1:<fun>}) ${2:<t>}"],
		"description": "applique une procÃ©dure Ã  un tableau"
	},

	"listrev": {
		"prefix": ["List.rev"],
		"body": ["List.rev ${1:<l>}"],
		"description": "Renvoie la liste renversÃ©e"
	},

	"listhd": {
		"prefix": ["List.hd"],
		"body": ["List.hd ${1:<l>}"],
		"description": "Renvoie la tÃªte de la liste"
	},

	"listtl": {
		"prefix": ["List.tl"],
		"body": ["List.tl ${1:<l>}"],
		"description": "Renvoie la queue de la liste"
	},

	"listlength": {
		"prefix": ["List.length"],
		"body": ["List.length ${1:<l>}"],
		"description": "Renvoie la longueur de la liste"
	},

	"randint": {
		"prefix": ["Random.int"],
		"body": ["Random.int ${1:<n>}"],
		"description": "Renvoie un entier alÃ©atoire de âŸ¦0,nâŸ§"
	},

	"randfloat": {
		"prefix": ["Random.float"],
		"body": ["Random.float ${1:<n>}"],
		"description": "Renvoie un flottant alÃ©atoire de [0,n] "
	},


	"Compare": {
		"prefix": ["match"],
		"body": ["match ${1:something} with", "| ${2}\t-> ${0}", "| ${3}\t-> "],
		"description": "Init a condition operator: match with"
	},

	"Compare a List": {
		"prefix": ["ml", "match_list"],
		"body": ["match ${1:liste} with", "| []\t-> ${2}", "| t::q\t-> ${0}"],
		"description": "Init a condition operator: match with for a list"
	},

	"Compare an Option": {
		"prefix": ["mo","match_option"],
		"body": ["match ${1:option} with", "| None\t\t-> ${2}", "| Some x\t-> ${0}"],
		"description": "Init a condition operator: match with for an option type"
	},
	
	"stringmake": {
		"prefix": ["String.make"],
		"body": ["String.make ${1:<len>} ${2:<value>}"],
		"description": "CrÃ©er une chaine de charactere de longueur len remplie de value "
	},

	"stringlen": {
		"prefix": ["String.length"],
		"body": ["String.length ${0:<tableau>}"],
		"description": "CrÃ©er un tableau (mutable) de longueur len remplie de value "
	},
    
	"Binary Tree": {
		"prefix": ["treeInit","arbre_bin"],
		"body": ["type 'a arbreBinaire = Vide | Noeud of ('a arbreBinaire * 'a * 'a arbreBinaire) ;;", "let feuille x = Noeud(Vide, x, Vide);;","let exemple = Noeud (Noeud(Vide, 2, feuille 1),5,Noeud(Vide,3,Noeud(Noeud(Vide, 0, Vide),2,Vide)));;"],
		"description": "Init a binary tree type with exemple"
	},

	"Binary Tree match": {
		"prefix": ["matchTreeBin"],
		"body": ["let rec affiche_arbre_suff=function","| Vide -> ${1:<code>} ","| Noeud(fg,e,fd) -> ${2:<code>}",";;"],
		"description": "Init a binary tree type with exemple"
	},
	
	"Non Binary Tree": {
		"prefix": ["tree-n","arbre_naire"],
		"body": ["type 'a arbre_naire = ", "| Node of 'a * 'a arbre_naire list","",
		"let test_tree = Node(0, [(Node(5,[]));(Node(13,[]));(Node(42,[]))])","","",
		"$BLOCK_COMMENT_START CONTRAT","Permet de recuperer la racine d'un arbre n-aire",
		"* Type  : racine: 'a arbre_naire -> 'a ",
		"* Param : abr, un arbre n-aire",
		"* Pre   : abr non Vide",
		"* Result: l'element en racine de l'arbre abr $BLOCK_COMMENT_END",
		"let racine (Node(racine,_)) = racine","","$BLOCK_COMMENT_START TESTS $BLOCK_COMMENT_END","",
		"let%test _ = racine (Node(1, [])) = 1",
		"let%test _ = racine (Node('z', [])) = 'z'",
		"let%test _ = racine (Node(\"test\", [])) = \"test\"","","","$BLOCK_COMMENT_START CONTRAT",
		"Permet de recuperer les fils d'un arbre n-aire",
		"* Type  : fils: 'a arbre_naire -> 'a arbre_naire list",
		"* Param : abr, un abre n-aire ",
		"* Pre   : abr non Vide",
		"* Result: la liste contenant les fils de m'arbre abr $BLOCK_COMMENT_END",
		"let fils (Node(_,fils)) = fils","","$BLOCK_COMMENT_START TEST $BLOCK_COMMENT_END","",
		"let%test _ = fils (Node(1, [])) = []",
		"let%test _ = fils arbre_test = [(Node(5,[]));(Node(13,[]));(Node(42,[]))]"],
		"description": "Init a non binary tree type and getters"
	},
    
	"Fold Left": {
		"prefix": ["left","fold_left"],
		"body": ["List.fold_left (fun acc t -> ${0:(t::acc)}) [] ${1:liste}"],
		"description": "Init a list iterator: fold left"
	},

	"Fold Right": {
		"prefix": ["right","fold_right"],
		"body": ["List.fold_right (fun t qt -> ${0:(t::qt)}) ${1:liste} []"],
		"description": "Init a list iterator: fold right"
	},

	"Map": {
		"prefix": ["map","List.map"],
		"body": ["List.map (fun elt -> ${0:elt modified}) ${1:liste}"],
		"description": "appliquer une fonction Ã  chaque Ã©lÃ©ment"
	},

	"Iteration": {
		"prefix": ["iter","List.iter"],
		"body": ["List.iter (fun elt -> ${0:elt modified}) ${1:liste}"],
		"description": "appliquer une procÃ©dure Ã  chaque Ã©lÃ©ment"
	},

	"listmem": {
		"prefix": ["List.mem"],
		"body": ["List.mem ${0:element} ${1:liste}"],
		"description": "Teste si l'Ã©lÃ©ment est prÃ©sent dans la liste"
	},

	"listfilter": {
		"prefix": ["List.filter"],
		"body": ["List.filter ${0:predicat} ${1:liste}"],
		"description": "Garde dans la liste les Ã©lÃ©ments compatible avec le prÃ©dicat"
	},

	"listexemple": {
		"prefix": ["Listexemple"],
		"body": ["let ${0:nom} = [1;2;3;4;5;6;7;8;9];;"],
		"description": "Ajoute une liste d'exemple"
	},

	"alpha": {
		"prefix": ["alpha"],
		"body": ["Î±"],
		"description": "Î±"
	},

	"beta": {
		"prefix": ["beta"],
		"body": ["Î²"],
		"description": "Î²"
	},

	"gamma": {
		"prefix": ["gamma"],
		"body": ["Î³"],
		"description": "Î³"
	},

	"Gamma": {
		"prefix": ["Gamma"],
		"body": ["Î“"],
		"description": "Î“"
	},

	"delta": {
		"prefix": ["delta"],
		"body": ["Î´"],
		"description": "Î´"
	},

	"Delta": {
		"prefix": ["Delta"],
		"body": ["Î”"],
		"description": "Î”"
	},

	"epsilon": {
		"prefix": ["epsilon"],
		"body": ["Îµ"],
		"description": "Îµ"
	},

	
	"zeta": {
		"prefix": ["zeta"],
		"body": ["Î¶"],
		"description": "Î¶"
	},

	"eta": {
		"prefix": ["eta"],
		"body": ["Î·"],
		"description": "Î·"
	},

	"theta": {
		"prefix": ["theta"],
		"body": ["Î¸"],
		"description": "Î¸"
	},

	"Theta": {
		"prefix": ["Theta"],
		"body": ["Î˜"],
		"description": "Î˜"
	},

	"iota": {
		"prefix": ["iota"],
		"body": ["Î¹"],
		"description": "Î¹"
	},

	"kappa": {
		"prefix": ["kappa"],
		"body": ["Îº"],
		"description": "Îº"
	},

	"lambda": {
		"prefix": ["lambda"],
		"body": ["Î»"],
		"description": "Î»"
	},

	"Lambda": {
		"prefix": ["Lambda"],
		"body": ["Î›"],
		"description": "Î›"
	},

	"ksi": {
		"prefix": ["ksi"],
		"body": ["Î¾"],
		"description": "Î¾"
	},
	
	"Ksi": {
		"prefix": ["Ksi"],
		"body": ["Î"],
		"description": "Î"
	},

	"pi": {
		"prefix": ["pi"],
		"body": ["Ï€"],
		"description": "Ï€"
	},

	"Pi": {
		"prefix": ["Pi"],
		"body": ["Î "],
		"description": "Î "
	},

	"rho": {
		"prefix": ["rho"],
		"body": ["Ï"],
		"description": "Ï"
	},
	
	"sigma": {
		"prefix": ["sigma"],
		"body": ["Ïƒ"],
		"description": "Ïƒ"
	},

	"Sigma": {
		"prefix": ["Sigma"],
		"body": ["Î£"],
		"description": "Î£"
	},

	"tau": {
		"prefix": ["tau"],
		"body": ["Ï„"],
		"description": "Ï„"
	},

	"upsilon": {
		"prefix": ["upsilon"],
		"body": ["Ï…"],
		"description": "Ï…"
	},

	"phi": {
		"prefix": ["phi"],
		"body": ["Ï•"],
		"description": "Ï•"
	},

	"Phi": {
		"prefix": ["Phi"],
		"body": ["Î¦"],
		"description": "Î¦"
	},

	"chi": {
		"prefix": ["chi"],
		"body": ["Ï‡"],
		"description": "Ï‡"
	},

	"psi": {
		"prefix": ["psi"],
		"body": ["Ïˆ"],
		"description": "Ïˆ"
	},

	"Psi": {
		"prefix": ["Psi"],
		"body": ["Î¨"],
		"description": "Î¨"
	},

	"omega": {
		"prefix": ["omega"],
		"body": ["Ï‰"],
		"description": "Ï‰"
	},

	"Omega": {
		"prefix": ["Omega"],
		"body": ["Î©"],
		"description": "Î©"
	},

	"leq": {
		"prefix": ["leq"],
		"body": ["â‰¤"],
		"description": "â‰¤"
	},
	"geq": {
		"prefix": ["geq"],
		"body": ["â‰¥"],
		"description": "â‰¥"
	},

	"approx": {
		"prefix": ["approx"],
		"body": ["â‰ˆ"],
		"description": "â‰ˆ"
	},

	"sqrt": {
		"prefix": ["sqrt"],
		"body": ["âˆš"],
		"description": "âˆš"
	},

	"infinity": {
		"prefix": ["infinity","inf"],
		"body": ["âˆ"],
		"description": "âˆ"
	},

	"EmptySet": {
		"prefix": ["EmptySet","EnsembleVide"],
		"body": ["âˆ…"],
		"description": "âˆ…"
	},

	"in": {
		"prefix": ["in"],
		"body": ["âˆˆ"],
		"description": "âˆˆ"
	},

	"r]]": {
		"prefix": ["rb"],
		"body": ["âŸ§"],
		"description": "âŸ§"
	},

	"l[[": {
		"prefix": ["lb"],
		"body": ["âŸ¦"],
		"description": "âŸ¦"
	},

	"not=": {
		"prefix": ["notequal","nequal"],
		"body": ["â‰ "],
		"description": "â‰ "
	},

	"R": {
		"prefix": ["RR"],
		"body": ["â„"],
		"description": "â„"
	},

	"Z": {
		"prefix": ["ZZ"],
		"body": ["â„¤"],
		"description": "â„¤"
	},

	"N": {
		"prefix": ["NN"],
		"body": ["â„•"],
		"description": "â„•"
	},

	"C": {
		"prefix": ["CC"],
		"body": ["â„‚"],
		"description": "â„‚"
	},

	"inter": {
		"prefix": ["inter"],
		"body": ["âˆ©"],
		"description": "âˆ©"
	},
	
	"forall": {
		"prefix": ["forall"],
		"body": ["âˆ€"],
		"description": "âˆ€"
	},

	"exists": {
		"prefix": ["exists"],
		"body": ["âˆƒ"],
		"description": "âˆƒ"
	},

	"int": {
		"prefix": ["int","entiere"],
		"body": [" âŒ${1:x}âŒŸ"],
		"description": "âŒxâŒŸ"
	},

	"AG": {
		"prefix": ["AG"],
		"body": ["ğ”„"],
		"description": "ğ”„"
	},
	"BG": {
		"prefix": ["BG"],
		"body": ["ğ”…"],
		"description": "ğ”…"
	},
	"CG": {
		"prefix": ["CG"],
		"body": ["â„­"],
		"description": "â„­"
	},
	"DG": {
		"prefix": ["DG"],
		"body": ["ğ”‡"],
		"description": "ğ”‡"
	},
	"EG": {
		"prefix": ["EG"],
		"body": ["ğ”ˆ"],
		"description": "ğ”ˆ"
	},
	"FG": {
		"prefix": ["FG"],
		"body": ["ğ”‰"],
		"description": "ğ”‰"
	},
	"GG": {
		"prefix": ["GG"],
		"body": ["ğ”Š"],
		"description": "ğ”Š"
	},
	"HG": {
		"prefix": ["HG"],
		"body": ["â„Œ"],
		"description": "â„Œ"
	},
	"IG": {
		"prefix": ["IG"],
		"body": ["â„"],
		"description": "â„"
	},
	"JG": {
		"prefix": ["JG"],
		"body": ["ğ”"],
		"description": "ğ”"
	},
	"KG": {
		"prefix": ["KG"],
		"body": ["ğ”"],
		"description": "ğ”"
	},
	"LG": {
		"prefix": ["LG"],
		"body": ["ğ”"],
		"description": "ğ”"
	},
	"MG": {
		"prefix": ["MG"],
		"body": ["ğ”"],
		"description": "ğ”"
	},
	"NG": {
		"prefix": ["NG"],
		"body": ["ğ”‘"],
		"description": "ğ”‘"
	},
	"OG": {
		"prefix": ["OG"],
		"body": ["ğ”’"],
		"description": "ğ”’"
	},
	"PG": {
		"prefix": ["PG"],
		"body": ["ğ”“"],
		"description": "ğ”“"
	},
	"QG": {
		"prefix": ["QG"],
		"body": ["ğ””"],
		"description": "ğ””"
	},
	"RG": {
		"prefix": ["RG"],
		"body": ["â„œ "],
		"description": "â„œ "
	},
	"SG": {
		"prefix": ["SG"],
		"body": ["ğ”–"],
		"description": "ğ”–"
	},
	"TG": {
		"prefix": ["TG"],
		"body": ["ğ”—"],
		"description": "ğ”—"
	},
	"UG": {
		"prefix": ["UG"],
		"body": ["ğ”˜"],
		"description": "ğ”˜"
	},
	"VG": {
		"prefix": ["VG"],
		"body": ["ğ”™"],
		"description": "ğ”™"
	},
	"WG": {
		"prefix": ["WG"],
		"body": ["ğ”š"],
		"description": "ğ”š"
	},
	"XG": {
		"prefix": ["XG"],
		"body": ["ğ”›"],
		"description": "ğ”›"
	},
	"YG": {
		"prefix": ["YG"],
		"body": ["ğ”œ"],
		"description": "ğ”œ"
	},
	"ZG": {
		"prefix": ["ZG"],
		"body": ["â„¨"],
		"description": "â„¨"
	},

	"binin": {
		"prefix": ["bclose"],
		"body": ["âŸ¦${1:a},${2:b}âŸ§"],
		"description": "âŸ¦a,bâŸ§"
	},
	"binout": {
		"prefix": ["bopen"],
		"body": ["âŸ¦${1:a},${2:b}âŸ¦"],
		"description": "âŸ¦a,bâŸ¦"
	},
	
	"I don't know": {
		"prefix": ["idk","ocaml"],
		"body": ["Â¯\\_(ãƒ„)_/Â¯"],
		"description": "When you end up unable to understand your own code"
	}
}